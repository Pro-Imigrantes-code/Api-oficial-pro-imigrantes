/// <reference types="node" />
import * as http from 'http';
import { FormData } from 'formdata-node';
import { RequestOptions } from 'https';
import { HTTPMethod } from '../sigaa-types';
import { HTTPSession } from './sigaa-http-session';
import { Page } from './sigaa-page';
/**
 * @category Public
 */
export declare type ProgressCallback = (totalSize: number, downloadedSize?: number) => void;
/**
 * @category Internal
 */
export interface SigaaRequestOptions {
    mobile?: boolean;
    noCache?: boolean;
    shareSameRequest?: boolean;
}
/**
 * @category Internal
 */
export interface HTTPRequestOptions extends RequestOptions {
    hostname: string;
    method: HTTPMethod;
    headers: Record<string, string>;
}
/**
 * @category Internal
 */
export interface HTTPResponse {
    bodyStream: NodeJS.ReadableStream;
    headers: http.IncomingHttpHeaders;
    statusCode: number;
}
/**
 * @category Internal
 * @instance
 */
export interface HTTP {
    /**
     * Make a POST multipart request
     * @param path The path of request or full URL
     * @param formData instance of FormData
     */
    postMultipart(path: string, formData: FormData, options?: SigaaRequestOptions): Promise<Page>;
    /**
     * Make a POST request
     * @param path The path of request or full URL
     * @param postValues Post values in format, key as field name, and value as field value.
     * @param [options]
     * @param [options.mobile] Use mobile User-Agent
     * @param [options.noCache] If can retrieve from cache
     */
    post(path: string, postValues: Record<string, string>, options?: SigaaRequestOptions): Promise<Page>;
    /**
     * Make a GET request
     * @param path The path of request or full URL
     * @param [options]
     * @param [options.noCache] If can retrieve from cache
     * @param [options.mobile] Use mobile User-Agent
     */
    get(path: string, options?: SigaaRequestOptions): Promise<Page>;
    /**
     * Download a file
     * @param urlPath file url
     * @param destpath path to save file
     * @param callback callback to view download progress
     */
    downloadFileByGet(urlPath: string, destpath: string, callback?: ProgressCallback): Promise<string>;
    /**
     * Download a file
     * @param urlPath file url
     * @param basepath path to save file
     * @param callback callback to view download progress
     */
    downloadFileByPost(urlPath: string, postValues: Record<string, string>, basepath: string, callback?: ProgressCallback): Promise<string>;
    /**
     * Follow the redirect while the page response redirects to another page
     * @param page
     * @returns The last page of redirects
     */
    followAllRedirect(page: Page, options?: SigaaRequestOptions): Promise<Page>;
    /**
     * Close http session
     */
    closeSession(): void;
}
/**
 * HTTP request class
 * @param sigaaSession A instance of SigaaSession
 *
 * @category Internal
 */
export declare class SigaaHTTP implements HTTP {
    private httpSession;
    constructor(httpSession: HTTPSession);
    /**
     * @inheritdoc
     */
    downloadFileByGet(urlPath: string, basepath: string, callback?: ProgressCallback): Promise<string>;
    /**
     * @inheritdoc
     */
    downloadFileByPost(urlPath: string, postValues: Record<string, string>, basepath: string, callback?: ProgressCallback): Promise<string>;
    /**
     * @inheritdoc
     */
    private downloadFile;
    /**
     * @inheritdoc
     */
    closeSession(): void;
    /**
     * Create object Options for https.request
     * @param method HTTP method POST or GET
     * @param link URL of Request
     * @param options
     * @param [options.withoutCookies=true] Disable cookies in headers, default = true
     * @param [options.mobile=false] Use mobile User-Agent
     * @returns The basic options for request
     */
    private getRequestBasicOptions;
    /**
     * @inheritdoc
     */
    postMultipart(path: string, formData: FormData, options?: SigaaRequestOptions): Promise<Page>;
    /**
     * Convert stream.Readable to buffer
     * @param stream readable stream
     */
    private convertReadebleToBuffer;
    /**
     * RFC 3986
     * Uses the UTF-8 code point to code, not the hexadecimal binary
     * @param str
     */
    private encodeWithRFC3986;
    /**
     * @inheritdoc
     */
    post(path: string, postValues: Record<string, string>, options?: SigaaRequestOptions): Promise<Page>;
    /**
     * Generate body and headers for post request
     * @param postValues
     * @param url
     * @param options
     */
    private encodePostValue;
    get(path: string, options?: SigaaRequestOptions): Promise<Page>;
    /**
     * Make a HTTP request for a page
     * @param url url of request
     * @param options http.request options
     * @param [requestBody] body of request
     */
    private requestPage;
    /**
     * Make a HTTP request
     * @param optionsHTTP http.request options
     * @param [body] body of request
     */
    protected requestHTTP(optionsHTTP: HTTPRequestOptions, body?: string | Buffer): Promise<HTTPResponse>;
    protected parserResponse(response: http.IncomingMessage): Promise<HTTPResponse>;
    followAllRedirect(page: Page, options?: SigaaRequestOptions): Promise<Page>;
}
